<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Pocket Bowl Retry</title>
	<style>
		/* Basic page reset */
		body {
			margin: 0;
			background: #222;
			height: 100vh;
			color: white;
			font-family: monospace;
		}

		/* Layout wrapper */
		#layout {
			display: flex;
			justify-content: center;
			align-items: center;
			gap: 24px;
			height: 100vh;
			padding: 20px;
			box-sizing: border-box;
		}

		/* Controls panel */
		#controlsPanel {
			width: 260px;
			height: 900px;
			background: #111;
			border: 2px solid #2f2f2f;
			box-shadow: 0 0 20px rgba(0,0,0,0.5);
			padding: 16px;
			box-sizing: border-box;
			display: flex;
			flex-direction: column;
			gap: 12px;
		}
		#controlsPanel h2 {
			margin: 0 0 6px 0;
			font-size: 18px;
			text-align: center;
		}
		#controlsPanel .section {
			background: #1a1a1a;
			border: 1px solid #2c2c2c;
			padding: 10px;
			border-radius: 6px;
		}
		#controlsPanel ul {
			margin: 8px 0 0 0;
			padding: 0 0 0 16px;
		}
		#controlsPanel li {
			margin: 4px 0;
		}
		#controlsPanel .hint {
			color: #b5b5b5;
			font-size: 12px;
		}

		/* Game container */
		#gameContainer {
			position: relative;
			width: 540px;
			height: 900px;
			box-shadow: 0 0 20px rgba(0,0,0,0.5);
			background: black;
		}
		canvas {
			background: #2e8b57;
		}

		/* HUD overlay */
		#ui-layer {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			display: flex;
			flex-direction: column;
			justify-content: space-between;
			padding: 20px;
			box-sizing: border-box;
		}
		#sidePanel {
			width: 220px;
			height: 900px;
			background: #111;
			border: 2px solid #2f2f2f;
			box-shadow: 0 0 20px rgba(0,0,0,0.5);
			padding: 16px;
			box-sizing: border-box;
			display: flex;
			flex-direction: column;
			gap: 12px;
		}
		#sidePanel h2 {
			margin: 0 0 6px 0;
			font-size: 18px;
			text-align: center;
		}
		#hudButtons {
			display: flex;
			flex-direction: column;
			gap: 10px;
		}
		#settingsBtn {
			background: #4aa3ff;
			color: #0b0b0b;
		}
		#settingsModal {
			display: none;
			background: #111;
			border: 2px solid #2f2f2f;
			box-shadow: 0 0 20px rgba(0,0,0,0.5);
			padding: 16px;
			border-radius: 6px;
		}
		#settingsModal.active {
			display: block;
		}
		.settingsRow {
			display: flex;
			flex-direction: column;
			gap: 6px;
			margin-top: 10px;
		}
		.settingsRow input {
			padding: 8px;
			border-radius: 4px;
			border: 1px solid #2c2c2c;
			background: #1a1a1a;
			color: white;
			font-family: monospace;
		}
		.settingsActions {
			display: flex;
			gap: 10px;
			margin-top: 12px;
		}
		#savePlayBtn {
			background: #1e1e1e;
			color: white;
			border: 1px solid #2c2c2c;
		}
		h1 {
			margin: 0;
			text-shadow: 2px 2px black;
		}
		#timer {
			font-size: 40px;
			color: yellow;
			font-weight: bold;
		}
		button {
			pointer-events: auto;
			padding: 10px 20px;
			cursor: pointer;
			font-size: 16px;
			background: orange;
			border: none;
			font-weight: bold;
		}
	</style>
</head>
<body>

<!-- Layout -->
<div id="layout">
	<!-- Controls Panel -->
	<aside id="controlsPanel">
		<h2>CONTROLS</h2>
		<div class="section">
			<div><strong>Prep</strong></div>
			<div>Drag blue players to draw routes.</div>
		</div>
		<div class="section">
			<div><strong>Throw</strong></div>
			<div>Press 1â€“5 to pass. Hold to lob.</div>
			<ul id="receiverList"></ul>
			<div class="hint">Numbers map to the labeled receivers on the field.</div>
		</div>
		<div class="section">
			<div><strong>Snap</strong></div>
			<div>Click SNAP BALL to start the play.</div>
		</div>
	</aside>

	<!-- Game Container -->
	<div id="gameContainer">
		<canvas id="gameCanvas" width="540" height="900"></canvas>

		<!-- HUD -->
		<div id="ui-layer">
			<div style="text-align:center;">
				<h1>POCKET BOWL</h1>
				<div id="timer">PREP: 5</div>
			</div>
		</div>
	</div>

	<!-- Right Side Buttons Panel -->
	<aside id="sidePanel">
		<h2>GAME</h2>
		<div id="hudButtons">
			<button id="snapBtn" tabindex="-1">SNAP BALL</button>
			<button id="pauseBtn" tabindex="-1">PAUSE</button>
			<button id="resetBtn" tabindex="-1">RESET</button>
			<button id="settingsBtn" tabindex="-1">GAME SETTINGS</button>
		</div>
		<div id="settingsModal">
			<div><strong>Settings</strong></div>
			<div class="settingsRow">
				<label for="yardLineInput">Start play at which yard line? (0-100)</label>
				<input id="yardLineInput" type="number" min="0" max="100" value="25" />
			</div>
			<div class="settingsRow">
				<label for="playNameInput">Name your play</label>
				<input id="playNameInput" type="text" placeholder="My Play" />
			</div>
			<div class="settingsActions">
				<button id="saveSettingsBtn" type="button">Save Yard Line</button>
				<button id="savePlayBtn" type="button">Save Last Play</button>
			</div>
		</div>
	</aside>
</div>

<!-- HUD Button Logic (Step 1 only) -->
<script>
	const pauseBtn = document.getElementById("pauseBtn");
	const resetBtn = document.getElementById("resetBtn");
	const settingsBtn = document.getElementById("settingsBtn");
	const settingsModal = document.getElementById("settingsModal");
	const yardLineInput = document.getElementById("yardLineInput");
	const playNameInput = document.getElementById("playNameInput");
	const saveSettingsBtn = document.getElementById("saveSettingsBtn");
	const savePlayBtn = document.getElementById("savePlayBtn");
	const timerLabel = document.getElementById("timer");
	let paused = false;
	window.retryState = window.retryState ?? {
		prepPhase: true,
		gameActive: false,
		isRouting: false,
		isPaused: false
	};
	const storedYard = localStorage.getItem("retry-yard-line");
	if (storedYard !== null) {
		yardLineInput.value = storedYard;
	} else {
		localStorage.setItem("retry-yard-line", String(yardLineInput.value));
	}

	pauseBtn.addEventListener("click", () => {
		paused = !paused;
		pauseBtn.textContent = paused ? "RESUME" : "PAUSE";
		timerLabel.textContent = paused ? "PAUSED" : "PREP: 5";
		window.retryState.isPaused = paused;
		if (typeof window.resetFrameTime === "function") {
			window.resetFrameTime();
		}
	});

	resetBtn.addEventListener("click", () => {
		window.location.reload();
	});

	const snapBtn = document.getElementById("snapBtn");
	if (snapBtn) {
		snapBtn.addEventListener("click", () => {
			if (window.retryState.isPaused) return;
			window.retryState.prepPhase = false;
			window.retryState.gameActive = true;
			timerLabel.textContent = "GO!";
			if (typeof window.resetFrameTime === "function") {
				window.resetFrameTime();
			}
		});
	}

	settingsBtn.addEventListener("click", () => {
		settingsModal.classList.toggle("active");
	});

	saveSettingsBtn.addEventListener("click", () => {
		const parsed = Number(yardLineInput.value);
		if (!Number.isNaN(parsed)) {
			const clamped = Math.max(0, Math.min(100, parsed));
			localStorage.setItem("retry-yard-line", String(clamped));
			yardLineInput.value = String(clamped);
			if (typeof applyFormationToLine === "function") {
				applyFormationToLine(yardLineToY(clamped));
			}
			snapLocked = false;
		}
	});

	savePlayBtn.addEventListener("click", () => {
		const playName = playNameInput.value.trim();
		if (!playName) return;
		const yardLine = Number(localStorage.getItem("retry-yard-line") ?? "25");
		const payload = {
			name: playName,
			yardLine,
			roster: typeof roster !== "undefined" ? roster.map(p => ({
				id: p.id,
				team: p.team,
				role: p.role,
				x: p.x,
				y: p.y,
				path: p.path ?? []
			})) : [],
			savedAt: new Date().toISOString()
		};
		localStorage.setItem(`retry-play-${playName}`, JSON.stringify(payload));
		localStorage.setItem("retry-last-play", playName);
		playNameInput.value = "";
	});
</script>

<!-- Core Data Models (Step 2) -->
<script>
	const FIELD_WIDTH = 540;
	const FIELD_HEIGHT = 900;
	const ENDZONE_HEIGHT = 50;
	const YARDS_PER_FIELD = 100;
	const DEFAULT_YARD_LINE =25;
	const FIELD_TOP_Y = ENDZONE_HEIGHT;
	const FIELD_BOTTOM_Y = FIELD_HEIGHT - ENDZONE_HEIGHT;
	const FIELD_PLAY_HEIGHT = FIELD_BOTTOM_Y - FIELD_TOP_Y;
	const LINE_COLOR = "rgba(255,255,255,0.3)";
	const LOS_COLOR = "rgba(255,255,255,0.8)";

	class Player {
		constructor(id, x, y, team, role) {
			this.id = id;
			this.x = x;
			this.y = y;
			this.startX = x;
			this.startY = y;
			this.baseX = x;
			this.baseYOffset = 0;
			this.team = team; // "offense" or "defense"
			this.role = role; // "QB", "WR", "LB"
			this.path = [];
			this.pathIndex = 0;
			this.speedYps = 6.7; // yards per second
			this.hasBall = (role === "QB");
			this.isDead = false;
		}

		reset() {
			this.x = this.startX;
			this.y = this.startY;
			this.path = [];
			this.pathIndex = 0;
			this.isDead = false;
			this.hasBall = (this.role === "QB");
		}
	}

	const roster = [
		// --- OFFENSE (Blue) ---
		new Player(1, 270, 820, "offense", "QB"),
		new Player(2, 150, 760, "offense", "WR"),
		new Player(3, 390, 760, "offense", "WR"),
		new Player(4, 270, 860, "offense", "RB"),
		new Player(5, 220, 760, "offense", "SL"),
		new Player(6, 320, 760, "offense", "SL"),
		new Player(7, 270, 760, "offense", "TE"),

		// --- DEFENSE (Red) ---
		new Player(8, 270, 700, "defense", "MLB"),
		new Player(9, 170, 700, "defense", "LB"),
		new Player(10, 370, 700, "defense", "LB"),
		new Player(11, 120, 620, "defense", "CB"),
		new Player(12, 420, 620, "defense", "CB"),
		new Player(13, 270, 580, "defense", "S"),
		new Player(14, 220, 700, "defense", "DL"),
		new Player(15, 320, 700, "defense", "DL")
	];

	const SPEED_YPS = {
		QB: 5.8,
		RB: 6.4,
		WR: 6.7,
		SL: 6.6,
		TE: 6.1,
		MLB: 6.0,
		LB: 6.1,
		DL: 5.4,
		CB: 6.6,
		S: 6.4
	};
	const SPEED_MULTIPLIER = 1.15; // edit this number to tweak overall speed! - master number 

	roster.forEach(player => {
		player.speedYps = (SPEED_YPS[player.role] ?? 6.0) * SPEED_MULTIPLIER;
	});

	function yardLineToY(yardLine) {
		const clamped = Math.max(0, Math.min(100, yardLine));
		const percent = clamped / YARDS_PER_FIELD;
		return FIELD_BOTTOM_Y - (percent * FIELD_PLAY_HEIGHT);
	}

	function setFormationOffsets() {
		const roleOffsetY = {
			QB: 70,
			RB: 120,
			WR: 20,
			SL: 20,
			TE: 20,
			MLB: -50,
			LB: -50,
			DL: -50,
			CB: -130,
			S: -190
		};

		roster.forEach(player => {
			player.baseX = player.x;
			const offset = roleOffsetY[player.role] ?? 0;
			player.baseYOffset = offset;
		});
	}

	function applyFormationToLine(lineY) {
		roster.forEach(player => {
			player.x = player.baseX;
			player.y = lineY + player.baseYOffset;
			player.startX = player.x;
			player.startY = player.y;
		});
	}

	const DEFAULT_LINE_OF_SCRIMMAGE_Y = yardLineToY(DEFAULT_YARD_LINE);

	function getLineOfScrimmageY() {
		const stored = Number(localStorage.getItem("retry-yard-line") ?? DEFAULT_YARD_LINE);
		return yardLineToY(stored);
	}

	setFormationOffsets();
	applyFormationToLine(getLineOfScrimmageY());

	console.log("[Step 2] Roster initialized:", roster);
</script>

<!-- Render Loop (Step 3) -->
<script>
	const canvas = document.getElementById("gameCanvas");
	const ctx = canvas.getContext("2d");
	const state = window.retryState ?? (window.retryState = {
		prepPhase: true,
		gameActive: false,
		isRouting: false,
		isPaused: false
	});
	let selectedPlayer = null;
	let lastFrameTime = null;
	const pixelsPerYard = FIELD_PLAY_HEIGHT / YARDS_PER_FIELD;
	let ballCarrier = roster.find(player => player.role === "QB") ?? roster[0];
	let ballFlight = null;
	const LOB_HOLD_MS = 400;
	const THROW_KEYS_MAX = 5;
	const keyHoldStart = {};
	const collisionDistance = 30;

	function handleInput(type, x, y) {
		if (!state.prepPhase && !state.gameActive) return;
		if (type === "start") {
			roster.forEach(player => {
				if (player.team !== "offense") return;
				const dist = Math.hypot(player.x - x, player.y - y);
				if (dist < 30) {
					state.isRouting = true;
					selectedPlayer = player;
					player.path = [];
					player.path.push({ x: player.x, y: player.y });
					player.path.push({ x, y });
					player.pathIndex = 0;
				}
			});
		} else if (type === "move" && selectedPlayer) {
			selectedPlayer.path.push({ x, y });
		} else if (type === "end") {
			selectedPlayer = null;
			state.isRouting = false;
		}
	}

	function getPos(event, type) {
		const rect = canvas.getBoundingClientRect();
		const point = event.touches ? event.touches[0] : event;
		const x = point.clientX - rect.left;
		const y = point.clientY - rect.top;
		handleInput(type, x, y);
	}

	canvas.addEventListener("mousedown", e => getPos(e, "start"));
	canvas.addEventListener("mousemove", e => getPos(e, "move"));
	canvas.addEventListener("mouseup", e => getPos(e, "end"));
	canvas.addEventListener("touchstart", e => getPos(e, "start"));
	canvas.addEventListener("touchmove", e => getPos(e, "move"));
	canvas.addEventListener("touchend", e => getPos(e, "end"));

	window.resetFrameTime = () => {
		lastFrameTime = null;
	};

	function getThrowTargets() {
		return roster.filter(player => player.team === "offense" && player.role !== "QB");
	}

	function defenderOnLine(start, end) {
		const threshold = 20;
		return roster.some(def => {
			if (def.team !== "defense") return false;
			const dist = pointToSegmentDistance(def.x, def.y, start.x, start.y, end.x, end.y);
			return dist < threshold;
		});
	}

	function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
		const dx = x2 - x1;
		const dy = y2 - y1;
		const lenSq = dx * dx + dy * dy;
		if (lenSq === 0) return Math.hypot(px - x1, py - y1);
		let t = ((px - x1) * dx + (py - y1) * dy) / lenSq;
		t = Math.max(0, Math.min(1, t));
		const projX = x1 + t * dx;
		const projY = y1 + t * dy;
		return Math.hypot(px - projX, py - projY);
	}

	function attemptThrow(targetPlayer, isLob) {
		if (!state.gameActive || state.isPaused) return;
		if (!ballCarrier || ballCarrier.team !== "offense") return;
		if (!targetPlayer || targetPlayer.team !== "offense") return;
		if (ballFlight?.active) return;

		const start = { x: ballCarrier.x, y: ballCarrier.y };
		const end = { x: targetPlayer.x, y: targetPlayer.y };
		ballCarrier.hasBall = false;

		if (!isLob && defenderOnLine(start, end)) {
			state.gameActive = false;
			ballCarrier = null;
			ballFlight = null;
			const timer = document.getElementById("timer");
			if (timer) timer.textContent = "INTERCEPTED";
			return;
		}

		ballFlight = {
			active: true,
			lob: isLob,
			startX: start.x,
			startY: start.y,
			x: start.x,
			y: start.y,
			target: targetPlayer,
			progress: 0,
			speed: isLob ? 0.012 : 0.03,
			arcHeight: isLob ? 120 : 0
		};

		ballCarrier = null;
	}

	function advanceBallFlight() {
		if (!ballFlight?.active) return;
		const progress = Math.min(1, ballFlight.progress + ballFlight.speed);
		ballFlight.progress = progress;
		const endX = ballFlight.target.x;
		const endY = ballFlight.target.y;
		const arcOffset = ballFlight.lob ? Math.sin(Math.PI * progress) * ballFlight.arcHeight : 0;
		ballFlight.x = lerp(ballFlight.startX, endX, progress);
		ballFlight.y = lerp(ballFlight.startY, endY, progress) - arcOffset;
		if (progress >= 1) {
			ballFlight.target.hasBall = true;
			ballCarrier = ballFlight.target;
			ballFlight.active = false;
		}
	}

	function lerp(a, b, t) {
		return a + (b - a) * t;
	}

	function handleThrowKeyDown(key) {
		if (!state.gameActive || state.isPaused) return;
		if (keyHoldStart[key]) return;
		keyHoldStart[key] = Date.now();
	}

	function handleThrowKeyUp(key) {
		if (!state.gameActive || state.isPaused) return;
		const started = keyHoldStart[key];
		if (!started) return;
		delete keyHoldStart[key];
		const index = Number(key) - 1;
		if (Number.isNaN(index) || index < 0 || index >= THROW_KEYS_MAX) return;
		const targets = getThrowTargets();
		const target = targets[index];
		if (!target) return;
		const heldMs = Date.now() - started;
		attemptThrow(target, heldMs >= LOB_HOLD_MS);
	}

	window.addEventListener("keydown", event => {
		if (event.repeat) return;
		if (event.key >= "1" && event.key <= String(THROW_KEYS_MAX)) {
			event.preventDefault();
			handleThrowKeyDown(event.key);
		}
	});

	window.addEventListener("keyup", event => {
		if (event.key >= "1" && event.key <= String(THROW_KEYS_MAX)) {
			event.preventDefault();
			handleThrowKeyUp(event.key);
		}
	});

	function updateReceiverList() {
		const list = document.getElementById("receiverList");
		if (!list) return;
		const targets = getThrowTargets();
		list.innerHTML = "";
		targets.slice(0, 5).forEach((player, index) => {
			const item = document.createElement("li");
			const button = document.createElement("button");
			button.type = "button";
			button.tabIndex = -1;
			button.textContent = `${index + 1}: ${player.role}`;
			let holdStart = 0;
			button.addEventListener("pointerdown", () => {
				holdStart = Date.now();
			});
			button.addEventListener("pointerup", () => {
				const heldMs = Date.now() - holdStart;
				attemptThrow(player, heldMs >= LOB_HOLD_MS);
			});
			button.addEventListener("pointerleave", () => {
				holdStart = 0;
			});
			item.appendChild(button);
			list.appendChild(item);
		});
	}

	function drawField() {
		ctx.clearRect(0, 0, canvas.width, canvas.height);

		ctx.fillStyle = "rgba(0,0,100,0.2)";
		ctx.fillRect(0, 0, canvas.width, ENDZONE_HEIGHT);
		ctx.fillRect(0, canvas.height - ENDZONE_HEIGHT, canvas.width, ENDZONE_HEIGHT);

		for (let yard = 0; yard <= 100; yard += 5) {
			const y = yardLineToY(yard);
			ctx.strokeStyle = LINE_COLOR;
			ctx.lineWidth = (yard % 10 === 0) ? 2 : 1;
			ctx.beginPath();
			ctx.moveTo(0, y);
			ctx.lineTo(canvas.width, y);
			ctx.stroke();
		}

		ctx.fillStyle = "rgba(255,255,255,0.9)";
		ctx.font = "12px Arial";
		ctx.textAlign = "left";
		for (let yard = 10; yard <= 90; yard += 10) {
			const label = yard <= 50 ? yard : 100 - yard;
			const y = yardLineToY(yard);
			ctx.fillText(String(label), 6, y + 4);
		}

		const losY = getLineOfScrimmageY();
		ctx.strokeStyle = LOS_COLOR;
		ctx.lineWidth = 3;
		ctx.setLineDash([10, 6]);
		ctx.beginPath();
		ctx.moveTo(0, losY);
		ctx.lineTo(canvas.width, losY);
		ctx.stroke();
		ctx.setLineDash([]);
	}

	function drawPlayers() {
		roster.forEach(p => {
			ctx.fillStyle = "rgba(0,0,0,0.5)";
			ctx.beginPath();
			ctx.arc(p.x + 2, p.y + 2, 15, 0, Math.PI * 2);
			ctx.fill();

			ctx.fillStyle = (p.team === "offense") ? "#0099ff" : "#ff3300";
			ctx.beginPath();
			ctx.arc(p.x, p.y, 15, 0, Math.PI * 2);
			ctx.fill();

			if (p.hasBall) {
				ctx.fillStyle = "brown";
				ctx.beginPath();
				ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
				ctx.fill();
			}

			ctx.fillStyle = "white";
			ctx.font = "10px Arial";
			ctx.textAlign = "center";
			ctx.fillText(p.role, p.x, p.y + 4);
		});

		if (ballFlight?.active) {
			ctx.fillStyle = ballFlight.lob ? "#d2b48c" : "brown";
			ctx.beginPath();
			ctx.arc(ballFlight.x, ballFlight.y, ballFlight.lob ? 7 : 6, 0, Math.PI * 2);
			ctx.fill();
		}
	}

	function drawRoutes() {
		roster.forEach(player => {
			if (player.team !== "offense" || player.path.length < 2) return;
			ctx.beginPath();
			ctx.strokeStyle = "yellow";
			ctx.lineWidth = 3;
			ctx.moveTo(player.path[0].x, player.path[0].y);
			player.path.forEach(point => {
				ctx.lineTo(point.x, point.y);
			});
			ctx.stroke();
		});
	}

	function moveOffense(deltaSeconds) {
		if (!state.gameActive || state.isRouting || state.isPaused) return;
		roster.forEach(player => {
			if (player.team !== "offense") return;
			if (!player.path || player.path.length < 2) return;
			if (player.pathIndex >= player.path.length) return;
			let target = player.path[player.pathIndex];
			let dx = target.x - player.x;
			let dy = target.y - player.y;
			let dist = Math.hypot(dx, dy);
			if (dist === 0) {
				player.pathIndex = Math.min(player.pathIndex + 1, player.path.length - 1);
				target = player.path[player.pathIndex];
				dx = target.x - player.x;
				dy = target.y - player.y;
				dist = Math.hypot(dx, dy);
				if (dist === 0) return;
			}
			const speedPx = player.speedYps * pixelsPerYard;
			const step = speedPx * deltaSeconds;
			if (dist <= step) {
				player.x = target.x;
				player.y = target.y;
				player.pathIndex = Math.min(player.pathIndex + 1, player.path.length - 1);
			} else {
				player.x += (dx / dist) * step;
				player.y += (dy / dist) * step;
			}
		});
	}

	function resolveCollisions() {
		roster.forEach(playerA => {
			roster.forEach(playerB => {
				if (playerA === playerB) return;
				if (playerA.team === playerB.team) return;
				const dx = playerB.x - playerA.x;
				const dy = playerB.y - playerA.y;
				const dist = Math.hypot(dx, dy);
				if (dist > 0 && dist < collisionDistance) {
					const overlap = (collisionDistance - dist) / 2;
					const nx = dx / dist;
					const ny = dy / dist;
					playerA.x -= nx * overlap;
					playerA.y -= ny * overlap;
					playerB.x += nx * overlap;
					playerB.y += ny * overlap;
				}
			});
		});
	}

	function render(timestamp) {
		if (!lastFrameTime) lastFrameTime = timestamp;
		const deltaSeconds = Math.min(0.05, (timestamp - lastFrameTime) / 1000);
		lastFrameTime = timestamp;

		updateReceiverList();
		advanceBallFlight();
		moveOffense(deltaSeconds);
		resolveCollisions();
		drawField();
		drawRoutes();
		drawPlayers();
		requestAnimationFrame(render);
	}

	render();
</script>

</body>
</html>
